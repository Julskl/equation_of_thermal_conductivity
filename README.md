##  Решение задачи теплопроводности для одномерного случая с помощью метода конечных разностей

Уравнение, описывающее изменение температуры в стержне:

$$
ρс\frac{\partial U}{\partial t} = λ^2 \frac{\partial^2 U}{\partial x^2}
$$

**Начальное условие** ($t=0$):
$$U(x, 0) = T_0, \quad 0 \le x \le L$$

**Граничное условие 1** ($x=0$):
$$U(0, t) = T_n, \quad t > 0$$

**Граничное условие 2** ($x=L$):
$$U(L, t) = T_n, \quad t > 0$$


Стержень разбивается на N–1 равных промежутков - получается конечно-разностная сетка. Полная явная схема:

$$
T_i^{n+1} = T_i^n + \alpha \tau \left( \frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{h^2} \right), \quad i=2,\dots,N-1, \ n \geq 0
$$

Где:
- $T_i^n$ — температура в узле $i$ на шаге $n$,
- $\tau$ — шаг по времени,
- $h$ — шаг по пространству,
- $\alpha$ — коэффициент теплопроводности.

Выбранную схему аппроксимации частных производных можно графически представить следующим образом:

<p align="center">
  <img width="456" height="324" alt="image" src="https://github.com/user-attachments/assets/28f8d694-e56c-41f8-acae-93c3fe1d4fea" />
    <br>
    <em> Шаблон явной четырехточечной разностной схемы </em>
</p>


Чтобы решение конечно-разностной задачи сходилось к решению дифференциальной задачи, достаточно выполнение следующего условия (условие устойчивости
разностной схемы):

$$\tau < \frac{\rho \cdot c \cdot h^2}{2 \cdot \lambda}$$

Из этого условия определяется шаг интегрирования по временной координате.


## Структура репозитория

- **gnu_octave/**
  - `temp.m` — реализация метода конечных разностей в GNU Octave;

- **c_pthreads/**
  - `sor_pthreads_adaptive_omega.c` — SOR с использованием POSIX threads (pthreads);
  - `Makefile` — сборка (`make`) и запуск (`make run`, параметры `THREADS`, `GRID` задаются в Makefile или через командную строку).

- **c_mpi/**
  - `sor_mpi_adaptive_omega.c` — распределённая реализация SOR с использованием MPI (C);
  - `Makefile` — сборка (`mpicc`) и локальный запуск (`make run`, параметры `PROCS`, `GRID`);
  - `run_112.slurm` — пример SLURM-скрипта для запуска на кластере (112 MPI-процессов).

- **py_mpi/**
  - `sor_mpi_adaptive_omega.py` — аналогичная MPI-реализация на Python с использованием `mpi4py` и `numpy`;
  - `Makefile` — запуск через `mpirun` (`make run`, параметры `PROCS`, `GRID`);
  - `run_112.slurm` — пример SLURM-скрипта для Python/MPI-версии.
 
- **c_openmp/**
  - `sor_OpenMP_adaptive_omega.c` — SOR с красно-чёрной схемой и адаптивным $\omega$, параллелизация с помощью OpenMP;
  - `Makefile` — сборка (`make`) и запуск (`make run` с параметрами `THREADS` и `GRID`).





















